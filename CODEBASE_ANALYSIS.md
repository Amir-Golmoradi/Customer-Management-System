# Go Customer Management System - Complete Codebase Analysis

## Project Overview
**Name:** Customer Management System  
**Language:** Go 1.25.7  
**Module:** `github.com/Amir-Golmoradi/Customer-Management-System`  
**Purpose:** A PostgreSQL-backed REST API for managing customer data  
**Docker Support:** Yes (Alpine-based multi-stage build)

---

## Architecture & Project Structure

```
CustomerSystem/
├── cmd/
│   └── api/
│       └── main.go                 # Application entry point
├── internal/
│   ├── config/
│   │   └── config.go               # Configuration management (env variables)
│   └── database/
│       ├── connections.go          # Database connection pooling
│       ├── sqlc.yaml               # SQLC code generation config
│       ├── sql/
│       │   ├── schema.sql          # Database schema definition
│       │   └── query.sql           # SQL queries for code generation
│       └── model/
│           ├── db.go               # Generated DBTX interface & Queries struct
│           ├── models.go           # Generated Customer model
│           └── query.sql.go        # Generated query methods
├── docker-compose.yml              # PostgreSQL development environment
├── Dockerfile                      # Container build configuration
├── go.mod                          # Module definition
└── go.sum                          # Dependency checksums
```

---

## Technology Stack

### Core Dependencies
- **PostgreSQL Driver:** `github.com/jackc/pgx/v5` (v5.8.0) - Modern PostgreSQL driver with connection pooling
- **Connection Pool:** `pgxpool` (included in pgx) - Manages database connections
- **Environment Variables:** `github.com/joho/godotenv` (v1.5.1) - Loads `.env` files
- **Code Generation:** `sqlc` (v1.30.0) - Generates type-safe database code from SQL

### Indirect Dependencies
- `pgx/v5` dependencies: `pgpassfile`, `pgservicefile`, `puddle/v2`
- `golang.org/x/sync` - Synchronization primitives
- `golang.org/x/text` - Text encoding/decoding

---

## Detailed Component Analysis

### 1. **Entry Point: `cmd/api/main.go`**
**Purpose:** Application initialization and bootstrap

**Functionality:**
- Loads configuration from environment variables
- Establishes PostgreSQL connection pool
- Initializes query interface
- Sets up context for graceful shutdown

**Current State:** Entry point is initialized but incomplete (queries created but not used)

```go
Key Operations:
1. context.Background() - Creates root context
2. config.Load() - Loads environment configuration
3. database.NewConnectionPool() - Creates connection pool
4. model.New(pool) - Creates Queries interface for database operations
```

---

### 2. **Configuration: `internal/config/config.go`**
**Purpose:** Centralized environment variable management

**Config Struct Fields:**
```go
DatabaseURL string  // Full connection string (e.g., "postgresql://user:pass@host:5432/db")
DBHost      string  // Database hostname
DBPort      string  // Database port
DBName      string  // Database name
DBUser      string  // Database username
DBPassword  string  // Database password
```

**Key Pattern:**
- Returns pointer to Config (`*Config`) to avoid copying in memory
- Uses `godotenv.Load()` to read `.env` file
- Returns config or error tuple

---

### 3. **Database Connection: `internal/database/connections.go`**
**Purpose:** Database pool initialization

**Function: `NewConnectionPool()`**
- Creates a PostgreSQL connection pool from connection string
- Returns `*pgxpool.Pool` for reusable connections
- Wraps `pgxpool.New()` for cleaner abstraction

**Benefits:**
- Connection pooling reduces overhead
- Reuses connections across requests
- Manages concurrent database access

---

### 4. **Database Models: `internal/database/model/`**

#### **Generated File: `db.go`**
Defines the DBTX interface and Queries struct (generated by SQLC)

**DBTX Interface:**
```go
type DBTX interface {
    Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
    Query(context.Context, string, ...interface{}) (pgx.Rows, error)
    QueryRow(context.Context, string, ...interface{}) pgx.Row
}
```

**Key Feature:** Supports transactions via `WithTx()` method - allows executing queries within a transaction

#### **Generated File: `models.go`**
Defines the `Customer` struct (generated by SQLC from schema)

```go
type Customer struct {
    ID        int32              // Primary key
    Name      string             // Customer name
    Email     string             // Unique email
    Password  string             // Hashed password (presumably)
    CreatedAt pgtype.Timestamp   // Automatic timestamp
}
```

#### **Generated File: `query.sql.go`**
Type-safe database query methods (generated from SQL)

**Available Methods:**
1. **`CreateCustomer(ctx, params)`**
    - Inserts new customer
    - Requires: Name, Email, Password
    - Returns: Full Customer object with generated ID and timestamp

2. **`GetCustomer(ctx, id)`**
    - Fetches customer by ID
    - Single customer or error

3. **`GetCustomerByEmail(ctx, email)`**
    - Fetches customer by email
    - Useful for authentication/lookup

4. **`ListCustomers(ctx)`**
    - Retrieves all customers
    - Ordered by ID
    - Returns slice of Customer

---

### 5. **Database Schema: `internal/database/sql/schema.sql`**
Defines PostgreSQL table structure

**Customers Table:**
```sql
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,           -- Auto-incrementing integer
  name VARCHAR NOT NULL,           -- Required text field
  email VARCHAR UNIQUE NOT NULL,   -- Unique constraint for no duplicates
  password VARCHAR NOT NULL,       -- Required text field
  created_at TIMESTAMP DEFAULT now() -- Auto timestamp on insert
);
```

---

### 6. **SQL Queries: `internal/database/sql/query.sql`**
Raw SQL queries with SQLC directives for code generation

**Directives:**
- `:one` - Query returns single row (method returns `Customer, error`)
- `:many` - Query returns multiple rows (method returns `[]Customer, error`)

---

### 7. **SQLC Configuration: `internal/database/sqlc.yaml`**
**Purpose:** Tells SQLC how to generate Go code from SQL

**Configuration:**
- **Schema Source:** `sql/schema.sql` - Database structure
- **Query Source:** `sql/query.sql` - SQL operations
- **Database Engine:** PostgreSQL
- **Output Package:** `model`
- **Output Directory:** `model/`
- **Driver:** `pgx/v5`

---

### 8. **Docker Configuration**

#### **`docker-compose.yml`**
Sets up PostgreSQL development environment

**Services:**
- **Image:** `postgres:18` - Latest PostgreSQL
- **Port:** 5432 (exposed to host)
- **Credentials:** postgres/secure-password
- **Database:** customers
- **Volume:** Persistent `db_data` volume

#### **`Dockerfile`**
Multi-stage build for production

**Build Stage (golang:alpine):**
- Compiles Go code
- Generates binary `/go/bin/app`

**Final Stage (alpine:latest):**
- Minimal production image
- Includes CA certificates (for HTTPS)
- Exposes port 3000
- Labels version 0.0.1

---

## Data Flow

```
Environment Variables (.env)
        ↓
config.Load() → Config struct
        ↓
database.NewConnectionPool(DatabaseURL) → *pgxpool.Pool
        ↓
model.New(pool) → *Queries
        ↓
Queries methods (CreateCustomer, GetCustomer, etc.)
        ↓
PostgreSQL Database
```

---

## Current Project State

### ✅ Completed
- Project setup with Go modules
- PostgreSQL driver integration
- SQLC code generation setup
- Database schema design
- SQL query definitions
- Configuration management
- Docker setup for development
- Connection pooling

### ⚠️ Incomplete
- No HTTP handlers or routes
- No REST API endpoints
- Main function doesn't use queries
- No error handling in main
- No middleware setup
- No validation logic
- No authentication system
- No graceful shutdown
- No logging framework

---

## Key Go Patterns Used

1. **Dependency Injection:** Database connection passed to Queries
2. **Interface Abstraction:** DBTX interface allows testing with mocks
3. **Context Pattern:** All queries use `context.Context` for cancellation
4. **Error Handling:** Functions return `(value, error)` tuples
5. **Pointer Receivers:** Config returned as pointer to avoid copies
6. **Code Generation:** SQLC automates type-safe query methods

---

## Environment Variables Required

```
DATABASE_URL=postgresql://postgres:secure-password@localhost:5432/customers
DB_HOST=localhost
DB_PORT=5432
DB_NAME=customers
DB_USER=postgres
DB_PASSWORD=secure-password
```

---

## Next Steps for Development

1. **Add HTTP Server:** Use `net/http` or a router like `chi`, `echo`, or `gin`
2. **Implement Handlers:** Create REST endpoints for CRUD operations
3. **Add Middleware:** Logging, error handling, CORS
4. **Implement Authentication:** JWT or session-based auth
5. **Add Validation:** Input validation for customer data
6. **Error Handling:** Custom error types and responses
7. **Logging:** Structured logging (e.g., with `slog` or `zap`)
8. **Testing:** Unit and integration tests
9. **Database Migrations:** Use tools like `migrate` or `goose`
10. **Health Checks:** Readiness/liveness probes for containers

---

## Summary

This is a **well-structured, modular Go application** with a solid foundation:
- Clean separation of concerns (cmd, internal/config, internal/database)
- Type-safe database access via SQLC
- Production-ready connection pooling
- Docker-ready for containerization

The infrastructure is ready for adding API handlers and business logic.
